#summary BSP data format.
#labels Phase-Implementation

This info is copied from the Descent Developer's Network [http://web.archive.org/web/20010906053232/descent-freespace.com/ddn/specs/idta/ bsp_data] page.

==Introduction==
The BSP data in FreeSpace in similar to the Descent 1-3 BSP data (also called IDTA). In FreeSpace, the BSP data is located in the POF files.

This document was written by John Slagel from Volition Inc., with revisions and bugfixing from Garry Knudson and Francis "Pastel" Avila.

==3D model data==
The first byte defines the block now following (0-5, see below). After a block the following byte defines the data of the next block, etc.

*0 - EOF - Means end of tree reached*
{{{
+ 0 int id = 0
+ 4 int size
}}}
*1 - DEFPOINTS - Defines the vertices*
{{{
+ 0 int id = 1
+ 4 int size
+ 8 int n_verts
+12 int n_norms
+16 int offset // from start of chunk to vertex data
+20 n_verts*char norm_counts
+offset vertex_data // Each vertex n is a point followed by norm_counts[n] normals.
}}}
*2 - FLATPOLY - Flat (non-textured) polygon*
{{{
+ 0 int id = 2
+ 4 int size 
+ 8 vector normal
+20 vector center
+32 float radius
+36 int nverts
+40 byte red
+41 byte green
+42 byte blue
+43 byte pad
for each vertex, i {
 short vertnum[i]
 short normnum[i]
}
}}}
*3 - TMAPPOLY - Textured polygons*
{{{
+ 0 int id = 3
+ 4 int size
+ 8 vector normal
+20 vector center
+32 float radius
+36 int nverts
+40 int tmap_num
for each vertex, i {
 ushort vertnum[i]
 ushort normnum[i]
 float u[i]
 float v[i]
}
}}}
*4 - SORTNORM - Sortnorms are planes that split the model recursively*
{{{
+ 0 int id = 4
+ 4 int size
+ 8 vector plane_normal
+20 vector plane_point
+32 int reserved // set to 0
+36 int front_offset // Only recurse into this if non-zero.
+40 int back_offset // Only recurse into this if non-zero.
+44 int prelist_offset // Only recurse into this if non-zero.
+48 int postlist_offset // Only recurse into this if non-zero.
+52 int online_offset // Only recurse into this if non-zero.
+56 vector min_bounding_box_point // of all polys under here
+68 vector max_bounding_box_point // of all polys under here
}}}
*5 - BOUNDBOX - Bounding boxes are used to speed up lighting and collision calculations.*
{{{
+ 0 int id = 5
+ 4 int size
+ 8 vector min_point
+20 vector max_point
}}}

==Notes==

The point of a BSP tree is to speed up rendering by splitting a model recursively in two, so that progressively smaller bounding boxes can speed up lighting and visibility calculations.  This is done by recursively bisecting the model and forming a list of polygons in front of the split and a list of polygons behind the split, and forming child nodes from those lists, which are also split.

===A few rules for FreeSpace BSP data===
 * A `sortnorm` is ALWAYS followed by three End-of-Tree blocks, representing what used to be `prelist`, `postlist`, and `online` when IDTA was an octree rather than a binary tree.
 * An End-of-Tree block ALWAYS follows a polygon block.
 * A bounding-box block ALWAYS preceeds a polygon block, to allow for faster lighting and collision calculation, as a leaf node of the BSP tree may contain multiple polygons.
 * It's unnecessary to designate the end of a branch with an End-of-Tree block, as `sortnorm`s do all the work.
 * The end of the entire BSP tree is designated by two End-of-Tree blocks following a polygon block.

===About the sortnorm block===
~~For one split of the model, two `sortnorm`s are needed.  They may share the same `plane_point`, but must have opposite `plane_normal`s.~~  The `front_offset` is the byte offset from the beginning of the block to the `sortnorm` of the first child node, and the `back_offset` is the byte offset from the beginning of the block to the `sortnorm` of this node's sibling.  The `prelist_offset`, `postlist_offset`, and `online_offset` should always point to an End-of-Tree block.  (Could we point them to just any EOT block?)

===Determining the front and back polylists===
 # Determine points ahead of and behind the plane
 # Find polygons that use ONLY points ahead of the plane, put them in `front_list`
 # Put all other polygons in `back_list`
 # Determine bounding boxes for each
We stop splitting when we reach a level where at least one leaf node will have only one polygon.  We can calculate how many children this will take.

====In more detail====
 # ~~Split your vertex coordinates list into verts_x, verts_y, and verts_z~~
 # ~~Determine minimum and maximum coordinates for this node~~
 # ~~If the length of the face list is less than three:~~
  * ~~Create a bounding box for each face~~
  * ~~If we're doing a BSP tree, add a boundbox node and the polygon node for each face~~
  * ~~If we're doing an SLDC chunk, add a leaf node with the face data~~
  * ~~Return~~
 # ~~Create a sortnorm for this node (a "split node" for the SLDC chunk)~~
 # ~~Determine the longest axis of this vertex list, and create a coordinate to split this axis exactly in half~~
  * ~~Determine all the faces which use only vertices in front of that point--these are your new front list~~
  * ~~All other faces are your back list for this node~~
 # ~~Recurse into the front list~~
 # ~~Upon return from the recursion, determine the size of all nodes added by the recursion~~
  * ~~This is the back offset, add it to the current node~~
 # ~~Recurse into the back list~~

====How PCS2 does it====
 # A bounding box and pointer to the list of polygons is passed to GenerateTreeRecursion()
 # GTR checks for infinite recursion
 # Find all polygons contained by passed bounds (store in "contained")
  * If only one, make a polygon node and return
  * Otherwise make a sortnorm node with the passed bounds
 # Calling Bisect() splits the bounds into front bounds and back bounds
  * GTR actually calls Bisect() and checks contained polygons several times, until it gets the number of polygons in each list roughly equal
  * Calling Bisect() also sets the plane point to the geometric center of the bounding box
 # Call GTR with front bounds, "contained"
 # Call GTR with back bounds, "contained"
 # Expand bounding box to accommodate children (necessary because of added padding throughout the process, usually around 0.1 units on all axes)

Notes: When checking for contained polygons, PCS2 uses the center of the polygon, rather than the polygon's bounds.  When making bounding boxes, however, it uses the polygon's physical bounds.

What we can infer from this: A sortnorm is a bounding box around both the front list _and_ the back list.  The splitting plane (given by a center point and a normal vector) gives the direction of "front."