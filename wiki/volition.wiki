#summary Breakdown of the volition module.
#labels Phase-Design

=Introduction=

This Python module provides various classes and methods useful for handling POF files.  A POF file is read by calling `read_pof(file)`.  As the function iterates through the file, it creates an object for each chunk.  Each chunk's constructor reads in raw binary data and fills out useful variables, such as `DockPointChunk.num_docks`.  The function returns a list of chunks that another function can iterate through to perform various operations with the data.

A POF file is written in a similar manner.  The `write_pof(list)` function takes a list of chunks and produces raw binary data which can be written in a file or further processed.

Reading a chunk goes like this:
 # A chunk is created with `this_chunk = DockPointChunk()`
  * A chunk can be also instantiated by passing the chunk's variables to the constructor, which can be used when writing chunks.
 # `this_chunk.read(raw_chunk_data)` is called.
 # The function reads through the raw data and assigns data to variables.

=Outline of classes and functions=

 * Exceptions
  * FileFormatError(StandardError) - Some part of the file being read or written indicates this is not, in fact, a POF file.
  * InvalidChunkError(StandardError) - Some part of this chunk is borked so the chunk can't be read or written.
  * InvalidBSPError(StandardError) - Some part of the BSP tree is borked so it can't be read or written.
  * VertListError(StandardError) - Some part of the vertex list is borked so a BSP tree can't be created.
  * FaceListError(StandardError) - Some part of the face list is borked so a BSP tree can't be created.
  * GeometryError(StandardError) - Some part of the geometry is borked, or the vertex list doesn't match the face list.  Either way, a BSP tree can't be created.
 * Wrappers for `pack()` and `unpack()`
  * unpack_byte()
  * unpack_char()
  * unpack_short()
  * unpack_ushort()
  * unpack_int()
  * unpack_uint()
  * unpack_float()
  * unpack_vector()
  * unpack_string()
  * pack_byte()
  * pack_char()
  * pack_short()
  * pack_ushort()
  * pack_int()
  * pack_uint()
  * pack_float()
  * pack_vector()
  * pack_string()
 * Helper classes and methods
  * `RawData` class
  * `vector()` method analogous to `int()` or `float()`
  * `Vertex` class
  * `Edge` class
  * `Face` class
  * `Mesh` class
 * Main POF-handling functions
  * read_pof()
  * write_pof()
 * Main BSP-generator functions
  * make_defpoints()
  * make_polylist()
  * generate_tree_recursion()
 * POF chunks (classes)
  * HeaderChunk
  * TextureChunk
  * PinfChunk
  * PathChunk
  * SpecialChunk
  * ShieldChunk
   * get_vert_list()
   * get_face_list()
   * set_vert_list()
   * set_face_list()
  * EyeChunk
  * GunChunk
  * TurretChunk
  * DockChunk
  * ThrusterChunk
  * SubmodelChunk
   * get_vert_list()
   * get_face_list()
   * make_bsp_tree()
  * LogoChunk
  * CenterChunk
  * GlowpointChunk
  * ShieldCollisionChunk
 * BSP blocks (classes)
  * DefpointsBlock
  * EndBlock
  * FlatpolyBlock
  * TmappolyBlock
  * SortnormBlock
  * BoundboxBlock

==SubmodelChunk==

_This section requires cleanup to be accurate according to the latest revision of the code._

This class has four methods in addition to `read()`, `write()`, `__init__()`, `__len__()`, and `__repr__()`.  Upon calling `read()`, the BSP data is parsed into a list of BSP blocks `self.bsp_data`.  Upon calling `write()`, `self.bsp_data` is parsed into a packed BSP tree along with the rest of the chunk.

 * `get_vert_list()` reads through `self.bsp_data` and stores `self.vert_list` as a list of `Vertex` objects.  Returns true if successful, raises `InvalidBSPError` if unsuccessful.
 * `get_face_list()` like `get_vert_list()`, but with faces.
 * `make_bsp_tree()` creates a list of BSP blocks `self.bsp_data` using `self.vert_list` and `self.face_list`.  Returns true if successful, raises various exceptions if unsuccessful, depending on the problem.

==Mesh==

This class is designed for use as an intermediary between a POF file's SHLD and SOBJ/OBJ2 chunks and another format such as Blender's internal geometry classes.  The class consists of a list of Vertex objects, a list of Edge objects, a list of Face objects, and methods for retrieving an indexed list of them, generating them from indexed lists, and working with vertex normals.

===Vertices===

Each vertex object is instantiated with a location and, optionally, one or more normals.

===Edges===

Edge objects are instantiated with a list of exactly two Vertex objects and, optionally, a boolean value for whether or not the edge is a seam (analogous to marking an edge as a seam in Blender or the boundary between two smoothing groups in 3DS Max).

===Faces===

Faces are instantiated with a list of Edge objects.  Upon instantiation, the centroid, radius, and normal of the face are calculated.

===calculate_vertex_normals()===

This method first creates several dictionary objects indexing vertices, edges, and faces with each other.  For example:
{{{
>>>vei # Vertex-Edge index
{0:[0, 3, 4, 7, 12], 1:[0, 5, 6, 11], ...}
# The key is the index of the vertex in the Mesh's vertex list
# The value is a sequence of edges which use that vertex, indexed to the Mesh's edge list
}}}

The method then goes through `vei` and, for each edge where `seam == False`, it goes through `efi` of that edge and adds the face's normal to a temporary variable, to be averaged at the end of the list.  For each edge where `seam == True`, the method simply goes through `efi` of that edge and adds a new normal to the vertex which is equal to each of the faces' normal.

===Vertex normal indexing===

There are a couple ways we could do this:

 * Store the index in each individual Face object.
 * Store the indices in another list/dictionary indexed into the face list.  (Indexception.)

Either way, with the current implementation of vertex normal calculation, we're going to have to match vertex normals to face normals (`if Face.normal in Vertex.normals` etc.).  It might be prudent to store vertex normals as a dictionary, with the keys simply being integers, as dictionaries are faster for membership testing.