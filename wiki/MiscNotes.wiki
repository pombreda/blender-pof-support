#summary Miscellaneous thoughts and notes for future reference.
#labels Phase-QA,Featured

==Testing the importer and exporter==
In the early stages, we can test the BSP tree generator by importing an existing POF file and exporting just a single submodel from it, then opening the resultant POF file in PCS or ModelView32.

Additional tests should include making sure calculated stuff equals actual values.  For example, `HeaderChunk.length` should ideally equal the length of the data passed when instantiating the class when reading from a POF file.

==Vertex normals==
Calculating vertex normals can only be done with an edge object with the boolean attribute `seam` or something similar to mark smoothgroups.  Something like:

{{{
class Mesh:
    vertices = list()
    edges = list()
    faces = list()
    class Vertex:
        coords = vector()
        normals = list() #sequence of vectors
    class Edge:
        vertices = list() #size=2
        seam = True
    class Face:
        edges = list()
        # __init__() function checks to make sure edges connect
        normal = vector()
        center = vector()
        radius = float()
    def make_vert_list()
    def make_face_list()
    def calculate_normals()
}}}

In this example, `Mesh` should be the main class we're working with, only creating `Vertex`, `Edge`, and `Face` objects to add them to a `Mesh` object as in `Mesh.vertices.append(Vertex(coords))`.  Assigning vertices to an edge will always take the form `Edge.vertices = [Mesh.vertices[1],Mesh.vertices[5]]`.  Example:

{{{
m = Mesh()
for v in vert_list:    #vert_list is a sequence of vectors
    m.vertices.append(Vertex(v))
for f in face_list:    #face_list is a 2-d sequence of vertex indices
    e = Edge()
    e.vertices = [m.vertices[f[0]],m.vertices[f[1]]
    m.edges.append(e)
    e.vertices = [m.vertices[f[1]],m.vertices[f[2]]
    m.edges.append(e)
    e.vertices = [m.vertices[f[2]],m.vertices[f[0]]
    m.edges.append(e)
    m.faces.append(Face(m.edges[len(m.edges)-4:]))
}}}

Something like this works because in Python, all names are treated as references.  If you have `a = Vertex()` and `b = Vertex()` and `c = [a, b]` and you change `a` or `b`, the change will be reflected in `c`.

==Mass and moment of inertia==
Can we use Blender's weight painting and [http://en.wikipedia.org/wiki/Spieker_center Spieker Center] calculation to calculate the mass, center of mass, and inertia tensor of a full-triangulated mesh?

==Version 0.1 and speed==
For the very first test releases, program speed is less important than release speed.  However, a few re-writes for optimization should be made shortly after the first fully-functional releases:
 * Membership testing with sets and dictionaries is much faster, O(1), than searching sequences, O(n). When testing "a in b", b should be a set or dictionary instead of a list or tuple.
 * String concatenation is best done with ''.join(seq) which is an O(n) process. In contrast, using the '+' or '+=' operators can result in an O(n**2) process because new strings may be built for each intermediate step. The CPython 2.4 interpreter mitigates this issue somewhat; however, ''.join(seq) remains the best practice.
 * In functions, local variables are accessed more quickly than global variables, builtins, and attribute lookups. So, it is sometimes worth localizing variable access in inner-loops. For example, the code for random.shuffle() localizes access with the line, random=self.random. That saves the shuffling loop from having to repeatedly lookup self.random. Outside of loops, the gain is minimal and rarely worth it.

Eventually (for v. 1.0 or v. 2.0) a rewrite of the volition module in C or C++ would be nice.  I'd rather not have to use an external module, but if performance does become an issue before a rewrite to C, we might have to use NumPy.

In the mean time, the exporter will be built from the beginning to be multi-threaded, getting the number of threads from Blender.

==Logging==
The importer and exporter should be able to output a log file containing all the POF data in a human-readable format.  We'll use the built-in `logging` module.

==Main `read_pof()` loop==
Since Python doesn't do switch-case statements, a dictionary lookup would be nice.  Something like:
{{{
chunk_id = get_the_chunk_id(pof_file.read(4))
chunk_length = get_the_chunk_length(pof_file.read(4))
chunk_bin = pof_file.read(chunk_length)
try:
    chunk = chunk_dict[chunk_id]()
    chunk.read_chunk(pof_file.read(chunk_length)
except KeyError:
    raise FileFormatError(chunk_id, "Unknown chunk detected - this is not a POF file.")
}}}

==PINF data==
The exporter will provide a field for custom PINF data (e.g. for a copyright statement).  After the custom PINF data, the exporter will write the following null-terminated strings:
{{{
"Exported from Blender {}, using exporter version {}, with volition package version {}".format(blender_version, exporter_version, volition_version)
"Max BSP depth was {}. Most polys in a single node was {}".format(max_bsp_depth, most_polys)
"Total compile time was {}ms, tree generation time was {}ms".format(pof_time, bsp_time)
}}}
Timing information will be calculated using a series of calls to `datetime.now()` and getting the time difference.

==Things that should have their own classes==
First rewrite, I'm going to make classes for each of these and have chunk objects deal with lists of these objects:
 * GenericPoint (position, normal)
 * GenericSpacePoint (position, radius, normal=False)
 * Path
 * PathVertex(GenericSpacePoint)
 * Subsystem(GenericSpacePoint)
 * Eye(GenericPoint)
 * GunSlot
 * GunPoint(GenericPoint)
 * TurretBank
 * TurretPoint(GenericPoint)
 * Dock
 * DockPoint(GenericPoint)
 * Thruster
 * ThrusterGlow(GenericSpacePoint)
 * Insignia
 * GlowBank
 * GlowPoint(GenericSpacePoint)