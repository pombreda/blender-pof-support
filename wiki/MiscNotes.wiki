#summary Miscellaneous thoughts and notes for future reference.
#labels Phase-QA,Featured

==Testing the importer and exporter==
In the early stages, we can test the BSP tree generator by importing an existing POF file and exporting just a single submodel from it, then opening the resultant POF file in PCS or ModelView32.

Additional tests should include making sure calculated stuff equals actual values.  For example, `HeaderChunk.length` should ideally equal the length of the data passed when instantiating the class when reading from a POF file.

==Vertex normals==
Calculating vertex normals can only be done with an edge object with the boolean attribute `seam` or something similar to mark smoothgroups.  Something like:

{{{
class Mesh:
    vertices = list()
    edges = list()
    faces = list()
    class Vertex:
        coords = vector()
        normals = list() #sequence of vectors
    class Edge:
        vertices = list() #size=2
        seam = True
    class Face:
        edges = list()
        # __init__() function checks to make sure edges connect
        normal = vector()
        center = vector()
        radius = float()
    def make_vert_list()
    def make_face_list()
    def calculate_normals()
}}}

In this example, `Mesh` should be the main class we're working with, only creating `Vertex`, `Edge`, and `Face` objects to add them to a `Mesh` object as in `Mesh.vertices.append(Vertex(coords))`.  Assigning vertices to an edge will always take the form `Edge.vertices = [Mesh.vertices[1],Mesh.vertices[5]]`.  Example:

{{{
m = Mesh()
for v in vert_list:    #vert_list is a sequence of vectors
    m.vertices.append(Vertex(v))
for f in face_list:    #face_list is a 2-d sequence of vertex indices
    e = Edge()
    e.vertices = [m.vertices[f[0]],m.vertices[f[1]]
    m.edges.append(e)
    e.vertices = [m.vertices[f[1]],m.vertices[f[2]]
    m.edges.append(e)
    e.vertices = [m.vertices[f[2]],m.vertices[f[0]]
    m.edges.append(e)
    m.faces.append(Face(m.edges[len(m.edges)-4:]))
}}}

Something like this works because in Python, all names are treated as references.  If you have `a = Vertex()` and `b = Vertex()` and `c = [a, b]` and you change `a` or `b`, the change will be reflected in `c`.

==Mass and moment of inertia==
Can we use Blender's weight painting and [http://en.wikipedia.org/wiki/Spieker_center Spieker Center] calculation to calculate the mass, center of mass, and inertia tensor of a full-triangulated mesh?