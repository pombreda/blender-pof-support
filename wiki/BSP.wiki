#summary BSP data format.
#labels Phase-Implementation

This info is copied from the Descent Developer's Network [http://web.archive.org/web/20010906053232/descent-freespace.com/ddn/specs/idta/ bsp_data] page.

==Introduction==
The BSP data in FreeSpace in similar to the Descent 1-3 BSP data (also called IDTA). In FreeSpace, the BSP data is located in the POF files.

This document was written by John Slagel from Volition Inc., with revisions and bugfixing from Garry Knudson and Francis "Pastel" Avila.

==3D model data==
The first byte defines the block now following (0-5, see below). After a block the following byte defines the data of the next block, etc.

*0 - EOF - Means end of tree reached*
{{{
+ 0 int id = 0
+ 4 int size
}}}
*1 - DEFPOINTS - Defines the vertices*
{{{
+ 0 int id = 1
+ 4 int size
+ 8 int n_verts
+12 int n_norms
+16 int offset // from start of chunk to vertex data
+20 n_verts*char norm_counts
+offset vertex_data // Each vertex n is a point followed by norm_counts[n] normals.
}}}
*2 - FLATPOLY - Flat (non-textured) polygon*
{{{
+ 0 int id = 2
+ 4 int size 
+ 8 vector normal
+20 vector center
+32 float radius
+36 int nverts
+40 byte red
+41 byte green
+42 byte blue
+43 byte pad
for each vertex, i {
 short vertnum[i]
 short normnum[i]
}
}}}
*3 - TMAPPOLY - Textured polygons*
{{{
+ 0 int id = 3
+ 4 int size
+ 8 vector normal
+20 vector center
+32 float radius
+36 int nverts
+40 int tmap_num
for each vertex, i {
 ushort vertnum[i]
 ushort normnum[i]
 float u[i]
 float v[i]
}
}}}
*4 - SORTNORM - Sortnorms are planes that split the model recursively*
{{{
+ 0 int id = 4
+ 4 int size
+ 8 vector plane_normal
+20 vector plane_point
+32 int reserved // set to 0
+36 int front_offset // Only recurse into this if non-zero.
+40 int back_offset // Only recurse into this if non-zero.
+44 int prelist_offset // Only recurse into this if non-zero.
+48 int postlist_offset // Only recurse into this if non-zero.
+52 int online_offset // Only recurse into this if non-zero.
+56 vector min_bounding_box_point // of all polys under here
+68 vector max_bounding_box_point // of all polys under here
}}}
*5 - BOUNDBOX - Bounding boxes are used to speed up lighting and collision calculations.*
{{{
+ 0 int id = 5
+ 4 int size
+ 8 vector min_point
+20 vector max_point
}}}

==Notes==

The point of a BSP tree is to speed up rendering by splitting a model recursively in two, so that progressively smaller bounding boxes can speed up lighting and visibility calculations.  This is done by recursively bisecting the model and forming a list of polygons in front of the split and a list of polygons behind the split, and forming child nodes from those lists, which are also split.

===A few rules for FreeSpace BSP data===
 * A `sortnorm` is ALWAYS followed by three End-of-Tree blocks, representing what used to be `prelist`, `postlist`, and `online` when IDTA was an octree rather than a binary tree.
 * An End-of-Tree block ALWAYS follows a polygon block.
 * A bounding-box block ALWAYS preceeds a polygon block, to allow for faster lighting and collision calculation, as a leaf node of the BSP tree may contain multiple polygons.
 * It's unnecessary to designate the end of a branch with an End-of-Tree block, as `sortnorm`s do all the work.
 * The end of the entire BSP tree is designated by two End-of-Tree blocks following a polygon block.

===About the sortnorm block===
For one split of the model, two `sortnorm`s are needed.  They may share the same `plane_point`, but must have opposite `plane_normal`s.  The `front_offset` is the byte offset from the beginning of the block to the `sortnorm` of the first child node, and the `back_offset` is the byte offset from the beginning of the block to the `sortnorm` of this node's sibling.  The `prelist_offset`, `postlist_offset`, and `online_offset` should always point to an End-of-Tree block.  (Could we point them to just any EOT block?)

===Determining the front and back polylists===
 # Determine points ahead of and behind the plane
 # Find polygons that use ONLY points ahead of the plane, put them in `front_list`
 # Put all other polygons in `back_list`
 # Determine bounding boxes for each
We stop splitting when we reach a level where at least one leaf node will have only one polygon.  We can calculate how many children this will take.